# 数据结构学习

学习地址：http://edu.51cto.com/course/6332.html   


## 其他链表

#### 单向循环链表（循环链表）
循环链表与单链表的区别仅仅在于其尾节点的链域值不是null，而是一个指向头节点的引用

循环链表的优点：从表中任何一个节点出发都能通过后移操作而扫描整个循环链表

单链表：每个节点所含的链域指向其后继节点，故从任一节点找其后继很方便，但要找到前趋节点则比较困难
```
ublic class Node {

    private String data;//数据域 可以是任何类型
    private Node next;//链域（下一个节点的地址）

```

双向链表：在每个节点中增加一个链域，所含引用所指向前趋节点
```
public class DoubleNode {

    String nodeName;  //节点信息
    DoubleNode prior; //指向前趋
    DoubleNode next;  //指向后继
    
}
```

#### 拓展
JDK中提供的链表：java.util.LinkedList (双向链表)   
声明链表：LinkedList list = new LinkedList();  
常用方法：  
1. Linked List();创建一个空链表
2. LinkedList(Collection elements)
3. boolean add(Object element)
4. void add(int index, Object element)



## 堆栈
堆是堆（heap），栈是栈（stack），堆栈是栈。嗯我很不喜欢“堆栈”这种叫法，容易让新人掉坑里  

1. 使用Stack类，java.util包中
2. 用链表模拟实现堆栈
3. 用数组模拟实现堆栈 ArrayOfStack类

特点：先进后出FILO（first in last out），编译程序的核心原理
堆栈的应用： 
1. 子程序的调用：
    在跳往子程序前，会先将下一个指令的地址存放到堆栈中，直到子程序执行完
    后再将地址取出，以回到原来的程序中
2. 处理递归调用：
   
3. 表达式的转换与求值：
    
4. 二叉树的遍历：

### 使用Stack类
Stack类表示后进先出（LIFO）的对象堆栈。它通过五个操作对类Vector进行了扩展，
允许将向量视为堆栈。
push(E item)：向栈中压入一个值
pop()：从栈顶弹出值
peek()；取栈顶点值用
boolean empty()：测试堆栈是否为空
int search(Object o)：在堆栈中查找并确定到栈顶距离


## 队列
队列中数据项的插入在一端（队列尾），而数据项的取得或者删除则是在另一端（队列头）
(first in first out)  

线性队列与循环队列 
线性队列存在 "假溢出" 问题这一致命问题，循环队列不存在

用数组实现队列   
1 队列声明  
2 入队操作  
3 出队操作  
4 队列遍历  


## 二叉树
二叉树结合了有序数组和链表两种数据结构的优点，
最多有两个子节点，因此允许只有一个子节点或者没有子节点  
二叉树的子树是有顺序关系的，所以结构相同的两颗树也是不同的二叉树  

三种遍历方式：  
先根遍历： 
中根遍历：先左边
后根遍历：

数组实现二叉树缺点是占用内存空间，优点是寻找夫节点、子节点、兄弟节点快速   
链表实现二叉树的优缺点与数组实现刚好相反

## 排序
交换式排序：
1.冒泡排序  
每趟排序都将最大值下层   
2.快速排序  
通常称其为分治法

插入式排序：
1.插入排序法

选择排序：
选择排序：
 找到最小元素，于第一个交换....（于冒泡排序相反） ，不适合大数据量排序，不稳定的排序
堆排序  





